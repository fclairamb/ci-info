package main

import (
	"bytes"
	"flag"
	"fmt"
	"os"
	"text/template"

	log "github.com/inconshreveable/log15"
)

func getParams() *CmdParams {
	params := &CmdParams{}
	flag.StringVar(&params.ConfigFile, "c", "", "config file")
	flag.BoolVar(&params.Version, "v", false, "version")
	flag.StringVar(&params.BuildInfoFile, "b", "", "build info file")
	flag.BoolVar(&params.Init, "init", false, "init config file")
	flag.Parse()

	return params
}

func generateBuildInfo(config *Config) (*BuildInfo, error) {
	var err error

	// The buildInfo struct is shared throughout the program to fill
	// all possible info we can get from the current build
	// and then export it to a json or template file.
	buildInfo := &BuildInfo{
		CIInfoVersion: BuildVersion,
	}

	// We get the CI info from the current CI environment
	if err = fetchCIInfo(buildInfo); err != nil {
		return nil, fmt.Errorf("failed to fetch CI info: %w", err)
	}

	// If GIT isn't disabled, we fetch the missing information using git commands
	if config.GitCmdMode {
		if err = fetchGitInfoWithCmd(buildInfo); err != nil {
			return nil, fmt.Errorf("failed to fetch git info: %w", err)
		}
	} else {
		if err = fetchGitInfoNative(buildInfo); err != nil {
			return nil, fmt.Errorf("failed to fetch git info: %w", err)
		}
	}

	// We fill the buildInfo struct with some information built from other parts of the struct
	if err := buildInfo.complete(); err != nil {
		return nil, fmt.Errorf("failed to complete build info: %w", err)
	}

	// At the very end we generate the version info
	if err := buildInfo.loadVersion(config); err != nil {
		return nil, fmt.Errorf("failed to load version info: %w", err)
	}

	return buildInfo, nil
}

func saveOutputFiles(config *Config, buildInfo *BuildInfo) error {
	// If requested, we export the build info to a json file
	if config.BuildInfoFile != "" {
		if err := buildInfo.save(config.BuildInfoFile); err != nil {
			return fmt.Errorf("failed to save build info: %w", err)
		}
	}

	// If request, we generate the build info file from a template
	for _, template := range config.Templates {
		if template.OutputFile != "" {
			var templateString string

			if template.InputContent != "" {
				templateString = template.InputContent
			} else {
				content, err := loadPathAsContent(template.InputFile)
				if err != nil {
					return fmt.Errorf("failed to load template file from %s: %w", template.InputFile, err)
				}
				templateString = string(content)
			}

			if err := applyTemplate(templateString, template.OutputFile, buildInfo); err != nil {
				return fmt.Errorf("failed to apply template: %w", err)
			}
		}
	}

	return nil
}

func main() {
	runMain(getParams())
}

func runMain(params *CmdParams) {
	var config *Config
	var err error

	// If requested, we report our version (generated by the tool itself)
	if params.Version {
		fmt.Println("Version:", BuildVersion)
		fmt.Println("Build time:", BuildDate)
		fmt.Println("Commit:", Commit)
		os.Exit(0)
	}

	// If requested, we create a default config file
	if params.Init {
		if errSave := saveDefaultConfig(params); errSave != nil {
			log.Crit("could not save default config", "err", errSave)
			os.Exit(1)
		} else {
			os.Exit(0)
		}
	}

	if params.ConfigFile == "" {
		if _, errStat := os.Stat(defaultConfigFile); errStat == nil {
			params.ConfigFile = defaultConfigFile
		}
	}

	// We load the config file
	if params.ConfigFile != "" {
		if config, err = loadConfig(params.ConfigFile); err != nil {
			log.Crit("Failed to load config from file", "file", params.ConfigFile, "err", err)
			os.Exit(1)
		}
	} else {
		config = &Config{}
	}

	if params.VersionFile != "" {
		config.Templates = append(config.Templates, &ConfigTemplate{
			InputContent: "{{ .Version }}",
			OutputFile:   params.VersionFile,
		})
	}

	log.Debug("Loaded config", "config", config)

	// If specified, we create the build info file
	if params.BuildInfoFile != "" {
		config.BuildInfoFile = params.BuildInfoFile
	}

	var buildInfo *BuildInfo

	if buildInfo, err = generateBuildInfo(config); err != nil {
		log.Crit("Failed to generate build info", "err", err)
		os.Exit(1)
	}

	if buildInfo.CommitHash == "" {
		log.Error("Could not find anything to use")
		os.Exit(1)
	}

	log.Info("Fetched build info", "buildInfo", buildInfo)

	// And then we generate all the output files
	if err = saveOutputFiles(config, buildInfo); err != nil {
		log.Crit("Failed to save output files", "err", err)
		os.Exit(1)
	}
}

func applyTemplate(templateString string, outputFile string, buildInfo *BuildInfo) error {
	var buffer bytes.Buffer

	if tpl, err := template.New("").Parse(templateString); err == nil {
		if errExec := tpl.Execute(&buffer, buildInfo); errExec != nil {
			return fmt.Errorf("could not execute template: %w", err)
		}
	} else {
		return fmt.Errorf("could not parse template: %w", err)
	}

	if err := os.WriteFile(outputFile, buffer.Bytes(), 0600); err != nil {
		return fmt.Errorf("could not write output file: %w", err)
	}

	return nil
}
