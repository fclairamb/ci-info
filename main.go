package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"text/template"

	log "github.com/inconshreveable/log15"
)

// CLI parameters
type CmdParams struct {
	ConfigFile    string
	BuildInfoFile string
	Version       bool
	Init          bool
}

// ConfigVersionInputFile defines how we shall fetch the input version
type ConfigVersionInputFile struct {
	File    string `json:"file"`
	Pattern string `json:"pattern"`
}

type ConfigVersionInputTag struct {
	Pattern string `json:"pattern"`
}

// ConfigTemplate
type ConfigTemplate struct {
	InputFile  string `json:"input_file"`
	OutputFile string `json:"output_file"`
}

// Config defines the configuration for ci-info
type Config struct {
	InputVersionFile ConfigVersionInputFile `json:"version_input_file"`
	InputVersionTag  ConfigVersionInputTag  `json:"version_input_tag"`
	Template         ConfigTemplate         `json:"template"`
	BuildInfoFile    string                 `json:"build_info_file"`
	DisableGitCmd    bool                   `json:"disable_git_cmd"`
}

type gitInfoFetch struct {
	info    *string
	command []string
}

const DefaultConfigFile = ".ci-info.json"

func loadConfig(fileName string) (*Config, error) {
	jsonContent, err := ioutil.ReadFile(fileName)
	if err != nil {
		return nil, err
	}
	config := &Config{}
	err = json.Unmarshal(jsonContent, config)
	if err != nil {
		return nil, err
	}
	return config, nil
}

func createDefaultConfig() *Config {
	return &Config{
		InputVersionFile: ConfigVersionInputFile{
			File:    "README.md",
			Pattern: "Version: ([0-9.]+)\n",
		},
		InputVersionTag: ConfigVersionInputTag{
			Pattern: "^v?([0-9.]+)$",
		},
		Template: ConfigTemplate{
			InputFile:  "build.go.tpl",
			OutputFile: "build.go",
		},
		BuildInfoFile: "build.json",
	}
}

func saveDefaultConfig(params *CmdParams) error {
	config := createDefaultConfig()
	jsonContent, err := json.MarshalIndent(config, "", "  ")
	if err != nil {
		return err
	}
	return ioutil.WriteFile(params.ConfigFile, jsonContent, 0644)
}

func getParams() *CmdParams {
	params := &CmdParams{}
	flag.StringVar(&params.ConfigFile, "c", "", "config file")
	flag.BoolVar(&params.Version, "v", false, "version")
	flag.StringVar(&params.BuildInfoFile, "b", "", "build info file")
	flag.BoolVar(&params.Init, "init", false, "init config file")
	flag.Parse()
	return params
}

func generateBuildInfo(config *Config) (*BuildInfo, error) {
	var err error

	// The buildInfo struct is shared throughout the program to fill
	// all possible info we can get from the current build
	// and then export it to a json or template file.
	buildInfo := &BuildInfo{
		CIInfoVersion: BuildVersion,
	}

	// We get the CI info from the current CI environment
	if err = fetchCIInfo(buildInfo); err != nil {
		return nil, fmt.Errorf("Failed to fetch CI info: %w", err)
	}

	// If GIT isn't disabled, we fetch the missing information using git commands
	if !config.DisableGitCmd {
		if err = fetchGitInfoWithCmd(buildInfo); err != nil {
			return nil, fmt.Errorf("Failed to fetch git info: %w", err)
		}
	}

	// We fill the buildInfo struct with some information built from other parts of the struct
	if err := buildInfo.complete(); err != nil {
		return nil, fmt.Errorf("Failed to complete build info: %w", err)
	}

	// At the very end we generate the version info
	if err := buildInfo.loadVersion(config); err != nil {
		return nil, fmt.Errorf("Failed to load version info: %w", err)
	}

	return buildInfo, nil
}

func saveOutputFiles(config *Config, buildInfo *BuildInfo) error {
	// If requested, we export the build info to a json file
	if config.BuildInfoFile != "" {
		if err := buildInfo.save(config.BuildInfoFile); err != nil {
			return fmt.Errorf("Failed to save build info: %w", err)
		}
	}

	// If request, we generate the build info file from a template
	if config.Template.OutputFile != "" {
		if err := applyTemplate(config.Template.InputFile, config.Template.OutputFile, buildInfo); err != nil {
			return fmt.Errorf("Failed to apply template: %w", err)
		}
	}

	return nil
}

func main() {
	params := getParams()

	var config *Config
	var err error

	// If requested, we report our version (generated by the tool itself)
	if params.Version {
		fmt.Println("Version:", BuildVersion)
		fmt.Println("Build time:", BuildDate)
		fmt.Println("Commit:", Commit)
		os.Exit(0)
	}

	// If requested, we create a default config file
	if params.Init {
		if errSave := saveDefaultConfig(params); errSave != nil {
			log.Crit("could not save default config", "err", errSave)
			os.Exit(1)
		} else {
			os.Exit(0)
		}
	}

	if params.ConfigFile == "" {
		if _, err := os.Stat(DefaultConfigFile); err == nil {
			params.ConfigFile = DefaultConfigFile
		}
	}

	// We load the config file
	if params.ConfigFile != "" {
		if config, err = loadConfig(params.ConfigFile); err != nil {
			log.Crit("Failed to load config from file", "file", params.ConfigFile, "err", err)
			os.Exit(1)
		}
	} else {
		config = &Config{}
	}

	log.Debug("Loaded config", "config", config)

	// If specified, we create the build info file
	if params.BuildInfoFile != "" {
		config.BuildInfoFile = params.BuildInfoFile
	}

	var buildInfo *BuildInfo
	if buildInfo, err = generateBuildInfo(config); err != nil {
		log.Crit("Failed to generate build info", "err", err)
		os.Exit(1)
	}

	if buildInfo.CommitHash == "" {
		log.Error("Could not find anything to use")
		os.Exit(1)
	}

	log.Info("Fetched build info", "buildInfo", buildInfo)

	// And then we generate all the output files
	if err = saveOutputFiles(config, buildInfo); err != nil {
		log.Crit("Failed to save output files", "err", err)
		os.Exit(1)
	}
}

func applyTemplate(inputFile string, outputFile string, buildInfo *BuildInfo) error {
	var templateString string
	if input, err := ioutil.ReadFile(inputFile); err != nil {
		return fmt.Errorf("could not read input file: %w", err)
	} else {
		templateString = string(input)
	}

	var buffer bytes.Buffer
	if tpl, err := template.New(inputFile).Parse(templateString); err != nil {
		return fmt.Errorf("could not parse template: %w", err)
	} else {
		if err := tpl.Execute(&buffer, buildInfo); err != nil {
			return fmt.Errorf("could not execute template: %w", err)
		}
	}

	if err := ioutil.WriteFile(outputFile, buffer.Bytes(), 0644); err != nil {
		return fmt.Errorf("could not write output file: %w", err)
	}

	return nil
}
